#!/bin/bash

set -eu
printf '\n'

# Colors
BOLD="$(tput bold 2>/dev/null || printf '')"
ITALIC="$(tput sitm 2>/dev/null || printf '')"
GREY="$(tput setaf 0 2>/dev/null || printf '')"
UNDERLINE="$(tput smul 2>/dev/null || printf '')"
RED="$(tput setaf 1 2>/dev/null || printf '')"
GREEN="$(tput setaf 2 2>/dev/null || printf '')"
YELLOW="$(tput setaf 3 2>/dev/null || printf '')"
BLUE="$(tput setaf 4 2>/dev/null || printf '')"
MAGENTA="$(tput setaf 5 2>/dev/null || printf '')"
NO_COLOR="$(tput sgr0 2>/dev/null || printf '')"

# RegExes
PASSWORD_IN_URL='//[^/\s:]+:[^/\s:]+@'
OUTPUTS_IN_NOTEBOOK='\"outputs\":\s+\['
AWS_URL='\S+.amazonaws.com'
IP_ADDRESS='\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b'
REGEXES=("$PASSWORD_IN_URL" "$OUTPUTS_IN_NOTEBOOK" "$AWS_URL" "$IP_ADDRESS")

info() {
  printf '%s\n' "${BOLD}${GREY}>${NO_COLOR} $*"
}

warn() {
  printf '%s\n' "${YELLOW}! $*${NO_COLOR}"
}

error() {
  printf '%s\n' "${RED}x $*${NO_COLOR}" >&2
}

completed() {
  printf '%s\n' "${GREEN}âœ“${NO_COLOR} $*"
}

has() {
  command -v "$1" 1>/dev/null 2>&1
}

verify_trufflehog_installed_or_exit() {
    if ! has trufflehog ; then
        error "Trufflehog is not installed, aborting audit!"
        exit 1
    else
        completed "Audit will use ${BOLD}trufflehog${NO_COLOR}"
        true  # No-op everything is ok
    fi
}

verify_bwrap_installed_or_exit() {
    if ! has bwrap ; then
        error "Bwrap is not installed, aborting audit!"
        exit 1
    else
        completed "Audit will use ${BOLD}bwrap${NO_COLOR}"
        true  # No-op everything is ok

    fi
}

verify_grep_is_installed_or_exit() {
    if has ugrep ; then
        GREP_ARGS=( -E -l --hidden --color=always -R )
        GREP="ugrep"
    elif has ripgrep; then
        GREP_ARGS=( -l --hidden --color always )
        GREP="rg"
    elif has grep; then
        GREP_ARGS=( -E -l -R -s --exclude-dir=.git )
        GREP="grep"
    else
        error "No grep installed neither some of the other supported similar tools (e.g. ugrep or ripgrep), aborting audit!"
        exit 1
    fi
    completed "Audit will be executed using ${BOLD}${GREP}${NO_COLOR}"
}

verify_git_is_installed_or_exit() {
    if ! has git ; then
        error "git is not installed, aborting audit!"
        exit 1
    else
        completed "Audit found ${BOLD}git${NO_COLOR} in the system"
        true
    fi
}

get_tmpdir() {
  git_repo="$1"
  if has mktemp; then
    printf "%s/%s" "$(mktemp -d)" "${git_repo}"
  else
    # No really good options here--let's pick a default + hope
    printf "/tmp/audit/%s" "${git_repo}"
  fi
}

usage() {
  printf "%s\n" \
    "audit-repo.sh [-vfhr] [--verbose] [--force] [--help] [--repositories[=]${ITALIC}repositories${NO_COLOR}...]" \
    "" \
    "Fetch and check for ${UNDERLINE}${BOLD}secrets${NO_COLOR} in the git repository " \
    "Plase note that this may come up with ${ITALIC}false positives${NO_COLOR} -- use your judgment on each result."

  printf "\n%s\n" "Options"
  printf "\t%s\n\t\t%s\n\n" \
    "-v, --verbose" "Enable verbose output for the audit" \
    "-f, -y, --force, --yes" "Skip the confirmation prompt during installation (will overwrite previous outputs)" \
    "-r, --repos, --repositories" "List of repositories to audit for secrets leakage" \
    "-h, --help" "Display this help message"
}

clone() {
    git_repo="$1"
    temp_dir="$2"
    git clone "${git_repo}" "${temp_dir}"  && completed "cloning ${git_repo} succeded" || (error "cloning ${git_repo} failed" && exit 1)
}

calculate_delta() {
   delta=$(( $(date -d "$1" +%s) - $(date -d "$2" +%s) ))
   printf '%s' $(date -d "@$delta" -u +%H:%M:%S)
}

audit_one() {
    local   initial_timestamp="$(date)"

    info "Started at $(date +'%Y-%m-%d %T')"

    git_url="$1"

    git_repo=$(basename $git_url .git)

    directory=$(get_tmpdir "$git_repo")

    info "Cloning repository $1"
    clone "${git_url}" "${directory}"

    info "Auditing repository's working directory"

    for rx in "${REGEXES[@]}"; do
        #echo $("${GREP} ${GREP_ARGS[@]} '\"${rx}\"' ${directory}")
        #echo $("${GREP}" "${GREP_ARGS[@]}" "${rx}" "${directory}" | xargs -L 1 basename)
        echo "$(${GREP} ${GREP_ARGS[@]} ${rx} ${directory})"
        completed "Completed checks for '${rx}'"
    done

    find "${directory}" -type f \( -name '*.csv' -o -name '*.txt' -o -name '*.zip' -o -name '*.png' \) ! -size 0
    completed "Searching for non-empty data or image files (${ITALIC}csv, txt, zip, png${NO_COLOR}) completed"

    info "Auditing git's commits history"

    cd "${directory}"
    for rx in "${REGEXES[@]}"; do
        #git rev-list --all | GIT_PAGER=cat xargs git grep -c "$rx"
	#git grep -E "${rx}" $(git rev-list --all)
        completed "Completed checks for '${rx}'"
    done

    trufflehog git file:///"${directory}"
    completed "Running trufflehog (checking for passwords, keys, etc) completed"

    local final_timestamp="$(date)"
    delta=$(calculate_delta "${final_timestamp}" "${initial_timestamp}")
    completed "Audition for ${BOLD}${git_repo} ${NO_COLOR} completed in ${delta}"
}

audit_all() {

    info "${UNDERLINE}Audition started ${NO_COLOR}"

    for git_repo in $GIT_REPOS; do
        info "Auditing ${ITALIC}${git_repo} ${NO_COLOR}"
        audit_one ${git_repo}
    done
}


# parse argv variables
while [ "$#" -gt 0 ]; do
 case "$1" in
  -v | --verbose)
    VERBOSE=1
    shift 1
    ;;
  -f | -y | --force | --yes)
    FORCE=1
    shift 1
    ;;
  -h | --help)
    usage
    exit
    ;;
  -r | --repos | --repositories)
    GIT_REPOS=$2
    shift 2
    ;;
  -v=* | --verbose=*)
    VERBOSE="${1#*=}"
    shift 1
    ;;
  -f=* | -y=* | --force=* | --yes=*)
    FORCE="${1#*=}"
    shift 1
    ;;
  -r=* | --repos=* | --repositories=*)
    GIT_REPOS="${1#*=}"
    shift 1
    ;;
  *)
    error "Unknown option: $1"
    usage
    exit 1
    ;;
  esac
done

printf "  %s\n" "${UNDERLINE}Checking dependencies${NO_COLOR}"

verify_grep_is_installed_or_exit
verify_git_is_installed_or_exit
verify_trufflehog_installed_or_exit

printf '\n'

printf "  %s\n" "${UNDERLINE}Configuration${NO_COLOR}"
info "${BOLD}Repositories to be audited${NO_COLOR}: ${GREEN}${GIT_REPOS}${NO_COLOR}"

# non-empty VERBOSE enables verbose untarring
if [ -n "${VERBOSE-}" ]; then
  VERBOSE=v
  info "${BOLD}Verbose${NO_COLOR}: yes"
else
  VERBOSE=
fi

printf '\n'

audit_all

completed "Audit completed!"

printf '\n'
info "Please check the recommendations (if any) (remember that potentially will be some ${ITALIC}false positives${NO_COLOR}) printed above to complete the cleaning of the repository"
